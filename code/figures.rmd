---
title: "Figures"
author: "Anton Ohlsson Collentine"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 6, fig.asp = 1.3)
```

```{r load data and packages}
library(readr) #To load data
library(dplyr) #For data transformation
library(purrr) #For data transformation
library(metafor) #To run meta-analyses
library(ggplot2) #Plot data
library(cowplot) #Combine several plots into one

dat <- read_csv("../data/collated_summary_data.csv")
```

```{r transformation_functions}
#Formulas found in: 
#Borenstein, M. (2009). Effect sizes for continuous data. In H. Cooper, L. V. Hedges, & J. C. Valentine (Eds.), The handbook of research synthesis and meta-analysis (2nd ed., pp. 221-235). New York: Russell Sage Foundation.

#For raw mean difference + SE
transform_SE <- function(ES, SE, n1, n2){ 
  sdpooled <- sqrt(SE^2 / (1 / n1 + 1/n2)) #Borenstein, M. (2009). In Cooper & Hedges. p. 224
  d <- ES / sdpooled
  corr <- (n1 + n2)^2 / (n1*n2) #correction factor if unequal sample sizes. p.234
  r <- d / sqrt(d^2 + corr) #p.234
  data.frame(r = r, n = n1 + n2)
}

#For mean differrence + SD
transform_SD <- function(m1, m2, SD1, SD2, n1, n2){ #assumes ES is raw mean difference
  sdpooled <- sqrt(((n1 - 1)*SD1^2 + (n2 - 1)*SD2^2) / (n1 + n2 - 2)) #page 226. 
  d <- (m1 - m2) / sdpooled
  corr <- (n1 + n2)^2 / (n1*n2) #correction factor if unequal sample sizes, p.234
  r <- d / sqrt(d^2 + corr) #p. 234
  data.frame(r = r, n = n1 + n2)
}

#For Risk difference/OR
transform_RD <- function(ai, bi, ci, di){
  ai <- ifelse(ai == 0, 0.5, ai)  #If value is equal to zero add one half so as to not divide by zero
  bi <- ifelse(bi == 0, 0.5, bi)  #This affects 1 study for Allowed vs. forbidden
  ci <- ifelse(ci == 0, 0.5, ci)  #And several studies for Low vs. high category scales
  di <- ifelse(di == 0, 0.5, di)
  logOR <- log((ai*di) / (bi*ci)) #p. 266
  d = logOR * sqrt(3)/pi #p. 232
  n1 = ai + bi
  n2 = ci + di
  corr <- (n1 + n2)^2 / (n1*n2) #correction factor if unequal sample sizes, p. 234
  r <- d / sqrt(d^2 + corr) #p. 234
  data.frame(r = r, n = ai + bi + ci +di)
}

#No transformatin needed for correlation


transform_MA <- function(x){
  if(any(x[, "effect_type"] == "Risk difference")){ #without the 'any' we will get warnings because we apply 'if' to a vector
    
    transformed <- transform_RD(ai = x$outcome_t1, bi = x$outcome_t2, ci = x$outcome_c1, di = x$outcome_c2)
    
    #fit <- rma(measure = "ZCOR", ri = zcor, ni = n, test = "knha", data = transformed)
    
  } else if(any(x[, "outcomes1_2"] == "mean _ SE")){  
    
     transformed <- transform_SE(x$effect_size, x$outcome_c2, x$ntreatment, x$ncontrol)
    
    #fit <- rma(measure = "ZCOR", ri = zcor, ni = n, test = "knha", data = transformed)
  
  } else if(any(x[, "outcomes1_2"] == "mean _ SD")){  
    
     transformed <- transform_SD(x$outcome_t1, x$outcome_c1, x$outcome_t2, x$outcome_c2, x$ntreatment, x$ncontrol)
    
    # fit <- rma(measure = "ZCOR", ri = zcor, ni = n, test = "knha", data = transformed)
 
  } else if(any(x[, "effect_type"] == "r")){
    
     transformed <- data.frame(r = x$effect_size, n = x$Ntotal)
    
    # fit <- rma(measure = "ZCOR", ri = zcor, ni = n, test = "knha", data = transformed)
 
   } else{ #For the many labs OR that were transformed to d [double check]
    
     transformed <- transform_RD(ai = x$outcome_t1, bi = x$outcome_t2, ci = x$outcome_c1, di = x$outcome_c2)
     
}
  
  # data.frame(b = fit$b[[1]], I2 = fit$I2) #estimate out
  transformed
}


```

```{r transform_df}
#Transform effect sizes to raw correlations
res <- dat %>% 
  split(.$effect) %>%  #separate by effect, necessary step otherwise the function is applied overall
  map_dfr(transform_MA, .id = "effect") #apply function and transform back from list to dataframe

```

```{r MA_df}
summarizer <- function(x){
  fit <- rma(measure = "ZCOR", ri = x$r, ni = x$n, data = x) #takes raw correlation as input
  data.frame(z = fit$b[[1]], I2 = fit$I2, H2trunc = fit$H2, H2 = fit$QE / (fit$k - 1)) #estimates out
}
#Default method of metafor for calculating H2 is truncated at one. Alternative method for calculating H2 provides information also on excessive homogeneity, i.e, less variability than expected by chance (that is, does not have a lower limit of 1). This method computes H2 as originally specified by Higgins & Thompson instead of using the more general method of metafor (see ?print.rma.uni).

#Higgins, J., & Thompson, S. G. (2002). Quantifying heterogeneity in a meta-analysis. Statistics in medicine, 21(11), 1539-1558.
  
res2 <- res %>% 
  split(.$effect) %>%  #separate by effect, necessary step otherwise the function is applied overall
  map_dfr(summarizer, .id = "effect") %>% 
  mutate(z = abs(z)) #Absolute values since we are interested in effect size rather than direction
```

```{r plot_res}

I2 <- ggplot(res2, aes(x = z, y = I2)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  xlab("Fisher's z") +
  coord_cartesian(ylim = c(0, 100)) +
  geom_text(x = 0.15, y = 80, label = "b = 69.40, R2 = 0.61", size = 3.5) +
  theme_classic()

# ggsave("I2_effect_size.png")

H2 <- ggplot(res2, aes(x = z, y = H2)) + 
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  xlab("Fisher's z") +
  geom_text(x = 0.14, y = 6, label = "b = 3.81, R2 = 0.53", size = 3.5) +
  theme_classic()

# ggsave("H2_effect_size.png")


effect_het <- plot_grid(I2, H2, nrow = 2, labels = c("A", "B"), align = "v") #combine plots
effect_het
# save_plot("effect_het.png", effect_het,
          # nrow = 2, base_aspect_ratio = 1.3)

# summary(lm(I2 ~ z, data = res2)) #b = 69.40, R2 = 0.61
# summary(lm(H2alt ~ z, data = res2)) #b = 3.81, R2 = 0.53
```

```{r labelled_plot, fig.asp= 0.618}
ggplot(res2, aes(x = z, y = I2, label = effect)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  xlab("Fisher's z") +
  coord_cartesian(ylim = c(0, 100)) +
  theme_classic() +
  geom_text(alpha = 0.5)
```


