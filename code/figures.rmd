---
title: "Figures main manuscript"
author: "Heterogeneity in direct replications in psychology and its association with effect size"
output: 
  pdf_document: 
    latex_engine: xelatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 6, fig.asp = 1.3)
```

```{r load packages, data and source helper functions}
if(!require(readr)){install.packages("readr")}
if(!require(metafor)){install.packages("metafor")}
if(!require(dplyr)){install.packages("dplyr")}
if(!require(purrr)){install.packages("purrr")}
if(!require(ggplot2)){install.packages("ggplot2")}
if(!require(cowplot)){install.packages("cowplot")}
if(!require(boot)){install.packages("boot")}

library(readr) #To load data
library(dplyr) #For data transformation
library(purrr) #For data iteration
library(metafor) #To run meta-analyses
library(ggplot2) #Plot data
library(cowplot) #Combine several plots into one
library(boot) #Bootstrap confidence intervals for correlations

dat <- read_csv("../data/collated_summary_data.csv")

source("helper_functions_tables_figures.r") #Load functions to prep data for figures
```

##Figure 1

```{r Plot_tau_against_I2, fig.asp = 0.618, cache = TRUE}
dat3 <- readRDS("../data/tau_simulation_results.RDS")
names(dat3) <- sort(unique(dat$effect)) #names were alphabetized upon splitting in simulation so must sort

OR2d <- c('Allowed vs. forbidden', 'Gain vs. loss framing', 'Norm of reciprocity', 'Low vs. high category scales') #effects that were transformed from OR to SMD

#Categorize effects by type of simulation for graphing
effect_type <- distinct(select(dat, effect, effect_type)) %>% 
  mutate(effect_type = ifelse(effect %in% OR2d | effect_type == "Risk difference" | 
                                effect_type == "Raw mean difference", "MD", effect_type),
         effect_type = recode(effect_type, "d" = 'SMD',
                              "r" = "Fisher's z"))



dat3 <- dat3 %>% 
  bind_rows(.id = "effect") %>% #create dataframe with identifier
  left_join(., effect_type) %>% 
  select(I2, tau, effect, effect_type) %>% 
  group_by(tau, effect, effect_type) %>% 
  summarize(I2 = mean(I2)) %>% #Take mean of I2 at each tau-level and for each effect
  ungroup()

#combined line plot gives good overview.
ggplot(dat3, aes(x = tau, y = I2, group = effect, color = effect_type)) +
  geom_line(alpha = 0.6) +
  theme_bw() +
  scale_x_continuous(name = expression(paste("Between studies standard deviation ", tau)),
                     minor_breaks = NULL) +
  scale_y_continuous(name = expression(paste(I^2," index", sep = "")),
                     minor_breaks = NULL) +
  coord_cartesian(ylim = c(0, 100)) +
  scale_color_brewer(name = "Effect type", palette = "Dark2", 
                     breaks = c("Fisher's z", "MD", "SMD")) +
  theme(legend.position = c(0.8, 0.4),
        legend.background = element_rect(linetype = "solid", color = "black")) +
  guides(color = guide_legend(override.aes = list(size = 1.4)))
  

# ggsave("../figures/tau-I2.png", dpi = 600, height =  4 , width = 6.47)

```

Figure 1. Result of simulation relating $I^2$-values to between studies standard deviation. Each line represent one of 37 effects. Tau is not directly comparable across effect size measures. 

##Figure 2

```{r Density-plot-prep, cache = TRUE}
#1) I2 plot----
dens <- readRDS("../data/power_simulation_results.RDS")
names(dens) <-  sort(unique(dat$effect))

#Simulated data at various heterogeneity levels, prep for plotting
I2_dist <- dens %>% 
  bind_rows(.id = "effect") %>% 
  rename(Heterogeneity = tau_index) %>% 
  mutate(Heterogeneity = recode(Heterogeneity,
                            '1' = "Zero",
                            '2' = "Small",
                            '3' = "Medium",
                            '4' = "Large"),
         Heterogeneity = as.factor(Heterogeneity))

#Observed I2 estimates, i.e, results from main table, see table.rmd
#Effects estimated with sourced function 'est_heterogeen_smd_raw'
observed <- dat %>% 
  split(.$effect) %>%  
  map_dfr(est_heterogen_smd_raw, .id = "effect") %>% 
  select(effect, I2 = s_I2) %>%
  mutate(Heterogeneity = "Observed")
```


```{r Density-plot, fig.height=4, fig.width=6.47}
I2_plot <- ggplot(I2_dist, aes(x = I2, group = Heterogeneity, fill = Heterogeneity, linetype = Heterogeneity)) +
  geom_histogram(data = observed, aes(y = ..density.., x = I2), bins = 100, alpha = 1) +
  geom_density(alpha = 0.3) +
  theme_classic() +
  coord_cartesian(xlim = c(0, 100))  +
  scale_fill_brewer(palette = "Dark2",
                    breaks = c("Zero", "Small", "Medium", "Large", "Observed"),
                    labels = c("Zero (0%)", "Small (25%)", "Medium (50%)", "Large (75%)", "Observed")) +
  scale_linetype_manual(values = c( "dotdash", "dotted", "solid", "solid", "dashed"),
                        breaks = c("Zero", "Small", "Medium", "Large", "Observed"), 
                        labels = c("Zero (0%)", "Small (25%)", "Medium (50%)", "Large (75%)", "Observed")) +
  scale_color_brewer(palette = "Dark2", 
                     breaks = c("Zero", "Small", "Medium", "Large", "Observed"),
                     labels = c("Zero (0%)", "Small (25%)", "Medium (50%)", "Large (75%)", "Observed")) +
  theme(legend.position = c(0.85, 0.71),
        legend.background = element_rect(linetype = "solid", color = "black")) +
  scale_y_continuous(name = "Density") +
  scale_x_continuous(name = expression(paste(I^2," index", sep = ""))) +
  guides(fill = guide_legend(override.aes = list(alpha = c(rep(0.3, 4), 1))))

I2_plot
# ggsave("../figures/density-I2.png", dpi = 600, height =  4, width = 6.47, device = cairo_pdf())


```

Figure 2. Simulated $I^2$  densities across 37 effects for zero, small, medium, and large heterogeneity according to the definitions of Higgins (2003), and a histogram of the observed $I^2$ estimates for the 37 effects. Each simulated density consists of approximately 370,000 estimates. 


##Figure 3, correlations per effect type


```{r corr_per_effect_type-prep, cache = TRUE}
#Each set of input datapoints is meta-analyzed as per the original replication project
#Then correlated with tau2 per effect type
#Function 'est_heterogen_smd_raw' is sourced, see also tables.rmd
tau2_per_type <- dat %>% 
  split(.$effect) %>%  
  map_dfr(est_heterogen_smd_raw, .id = "effect")

MD_fit <- function(x){
    fit <- rma(measure = "SMD", m1i = outcome_t1, m2i = outcome_c1, sd1i = outcome_t2, sd2i = outcome_c2, n1i = ntreatment, n2i = ncontrol, data = x)
    hetero <- confint(fit)$random[c(1, 3), ] 
    data.frame(eff_size = fit$b[[1]], #effect size (point estimate) 
             s_I2 = hetero[2, 1], s_ci.lb = hetero[2, 2], s_ci.ub = hetero[2, 3],
             tau2 = hetero[1, 1], tau2_ci.lb = hetero[1, 2], tau2_ci.ub = hetero[1, 3],
             H2trunc = fit$H2, H2 = fit$QE / (fit$k - 1))
}


OR_fit <- function(x){
    fit <- rma(measure = "OR", ai = outcome_t1, bi = outcome_t2, ci = outcome_c1, di = outcome_c2, n1i = ntreatment, n2i = ncontrol,  data = x)
    hetero <- confint(fit)$random[c(1, 3), ] 
    data.frame(eff_size = fit$b[[1]], #effect size (point estimate) 
             s_I2 = hetero[2, 1], s_ci.lb = hetero[2, 2], s_ci.ub = hetero[2, 3],
             tau2 = hetero[1, 1], tau2_ci.lb = hetero[1, 2], tau2_ci.ub = hetero[1, 3],
             H2trunc = fit$H2, H2 = fit$QE / (fit$k - 1))
}



#Raw mean differences to SMD
MD_standardized <- dat %>% 
  filter(outcomes1_2 == "mean _ SD") %>% #Note, drops Mean _ SE study since no method in metafor to convert into standardized mean differences
  split(.$effect) %>% 
  map_dfr(MD_fit, .id = "effect")

#effects that were originally transformed from OR to SMD by ML1 which we refit as OR
OR2d <- c('Allowed vs. forbidden', 'Gain vs. loss framing', 
           'Norm of reciprocity', 'Low vs. high category scales') 

ml2_or <- c("Affect & Risk", "Trolley Dilemma 1", "Framing", "Trolley Dilemma 2") #odds ratio effects in ML2 we will fit as OR

odds_ratios <- dat %>% 
  filter(effect %in% c(OR2d, ml2_or)) %>% 
  split(.$effect) %>% 
  map_dfr(OR_fit, .id = "effect")


tau2_per_type <- dat %>% #This is to add the effect_type names
  select(effect, effect_type) %>% 
  distinct() %>% #get unique rows
  mutate(effect_type = recode(effect_type, 
                              d = "Standardized Mean Difference")) %>% 
  left_join(tau2_per_type) %>% #Add the meta-analytic results
  filter(!effect %in% c(odds_ratios$effect, MD_standardized$effect)) %>% #drop old odds ratio effects and unstandardized MD
  bind_rows(MD_standardized) %>% #add MD after standardization
  bind_rows(odds_ratios) %>% #add odds ratios
  mutate(effect_type = ifelse(effect %in% MD_standardized$effect, "Standardized Mean Difference", effect_type),
         effect_type = ifelse(effect %in% odds_ratios$effect, "Odds Ratio", effect_type),
         eff_size = abs(eff_size)) %>% #need the absolute values for plotting
  filter(effect_type %in% c("Standardized Mean Difference", "Odds Ratio"))


#labels for figure 3----
fitter <- function(df){  #function to fit correlations for annotating facet plots
 fit_tau2 <- summary(lm(tau2 ~ eff_size, data = df))
 fit_I2 <- summary(lm(s_I2 ~ eff_size, data = df))
 fit_H2 <- summary(lm(H2 ~ eff_size, data = df))
 b <- c(fit_tau2$coefficients[2, 1], fit_I2$coefficients[2, 1], fit_H2$coefficients[2, 1])
 r <- c(sqrt(fit_tau2$r.squared), sqrt(fit_I2$r.squared), sqrt(fit_H2$r.squared))
 data.frame(b = format(round(b, digits = 2), nsmall = 2), 
            r = format(round(r, digits = 2), nsmall = 2),
            index = c("tau2", "I2", "H2")) 
}


#functions to estimate bootstrapped confidence intervals to add to plot correlations
pear_tau2 <- function(formula, data, indices){ #pearson
     d <- data[indices,]
     fit <- cor.test(formula = ~ tau2 + eff_size, data=d)
     return(fit$estimate)
}
pear_I2 <- function(formula, data, indices){ #pearson
     d <- data[indices,]
     fit <- cor.test(formula = ~ s_I2 + eff_size, data=d)
     return(fit$estimate)
}
pear_H2 <- function(formula, data, indices){ #pearson
     d <- data[indices,]
     fit <- cor.test(formula = ~ H2 + eff_size, data=d)
     return(fit$estimate)
}

bootfitter <- function(x){ #function that computes the bootstrapped confidence intervals using above functions to annotate plots
  bootfit <- boot(data=x, statistic=pear_tau2, R=1000, formula= ~ eff_size + tau2)
  tau2_ci_pears <- boot.ci(bootfit, type="perc")
  bootfit <- boot(data=x, statistic=pear_I2, R=1000, formula= ~ eff_size + s_I2)
  I2_ci_pears <- boot.ci(bootfit, type="perc")
  bootfit <- boot(data=x, statistic=pear_H2, R=1000, formula= ~ eff_size + H2)
  H2_ci_pears <- boot.ci(bootfit, type="perc")

  ci.lb <- c(tau2_ci_pears$percent[4], I2_ci_pears$percent[4], H2_ci_pears$percent[4])
  ci.ub <- c(tau2_ci_pears$percent[5], I2_ci_pears$percent[5], H2_ci_pears$percent[5])

  ci <- paste0("[", format(round(ci.lb, 2), nsmall = 2), ", ",
       format(round(ci.ub, 2), nsmall = 2), "]")#percentile 
  data.frame(ci, index = c("tau2", "I2", "H2"))
}

set.seed(435) #for the bootstrapping
fig3_ci <- tau2_per_type %>% 
  split(.$effect_type) %>% 
  map_dfr(bootfitter, .id = "effect_type")


labels <- tau2_per_type %>% #row 1:2 = tau2, row 3:4 = I2, row 5:6 = H2
  split(.$effect_type) %>% 
  map_dfr(fitter, .id = "effect_type") %>%
  mutate(r = ifelse(r == 0.15, -0.15, r), #should be negative, but I took squared root of R^2 to get correlations so needs correction
         lab = paste0("b = ", b, ", r = ", r, " ", fig3_ci$ci)) #put output into one variable for improved plotting


```


```{r corr_per_effect_type-plot, cache = FALSE}
#tau2plot----
tau2_facet <- ggplot(tau2_per_type, aes(x = eff_size, y = tau2)) + 
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE, color = "black") + #to set alpha for the line geom_line must be used rather than geom_smooth
  geom_text(data = labels[labels$index == "tau2",], aes(label = lab), x = -Inf, y = Inf, hjust = -0.1, vjust = 2, size = 3.5, fontface = "italic", alpha = .6) + #hjust and vjust can be used to annotate the same position in all facets even though the scale are different
  scale_y_continuous(name = expression(paste("Between studies variance ", italic(tau)^2))) +
  scale_x_continuous(name = "Effect size") +
  theme_classic() +
  theme(strip.background = element_blank(), #remove box around titles
        strip.text = element_text(size = 12),
        panel.border = element_rect(fill = NA, colour = "black", #add box around plots
                                    size = 0.5, linetype = "solid")) + 
  facet_wrap(~effect_type, nrow = 2, scales = "free") #use free scales since scales are different

#I2plot----
I2_facet <- ggplot(tau2_per_type, aes(x = eff_size, y = s_I2)) + 
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE, color = "black") + #to set alpha for the line geom_line must be used rather than geom_smooth
  geom_text(data = labels[labels$index == "I2",], aes(label = lab), x = -Inf, y = Inf, hjust = -0.1, vjust = 2, size = 3.5, fontface = "italic", alpha = .6) + #hjust and vjust can be used to annotate the same position in all facets even though the scale are different
  scale_y_continuous(name = expression(paste(italic(I)^2, " Index"))) +
  scale_x_continuous(name = "Effect size") +
  coord_cartesian(ylim = c(0, 100)) +
  theme_classic() +
  theme(strip.background = element_blank(), #remove box around titles
        strip.text = element_text(size = 12),
        panel.border = element_rect(fill = NA, colour = "black", #add box around plots
                                    size = 0.5, linetype = "solid")) + 
  facet_wrap(~effect_type, nrow = 2, scales = "free") #use free scales since scales are different

#H2plot----
H2_facet <- ggplot(tau2_per_type, aes(x = eff_size, y = H2)) + 
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE, color = "black") + #to set alpha for the line geom_line must be used rather than geom_smooth
  geom_text(data = labels[labels$index == "H2",], aes(label = lab), x = -Inf, y = Inf, hjust = -0.1, vjust = 2, size = 3.5, fontface = "italic", alpha = .6) + #hjust and vjust can be used to annotate the same position in all facets even though the scale are different
  scale_y_continuous(name = expression(paste(italic(H)^2, " Index"))) +
  scale_x_continuous(name = "Effect size") +
  theme_classic() +
  theme(strip.background = element_blank(), #remove box around titles
        strip.text = element_text(size = 12),
        panel.border = element_rect(fill = NA, colour = "black", #add box around plots
                                    size = 0.5, linetype = "solid")) + 
  facet_wrap(~effect_type, nrow = 2, scales = "free") #use free scales since scales are different

#combined----
combo <- cowplot::plot_grid(tau2_facet, I2_facet, H2_facet, labels = "AUTO")
#ggsave("../figures/effect-het.png", dpi = 600, height =  7, width = 7)
combo
```

Figure 3. The correlation between effect size and A) tau2, B) I2 and C) H2 respectively  40 effects that were measured as mean or standardized mean differences and 8 effects measured as odds ratios from 13 pre-registered multi-lab replication projects. Effects reported as mean differences were standardized. Square brackets contain 95% bootstrapped percentile confidence intervals.


```{r cor_het_effect_size, results = "hide", cache=TRUE}

#This section gives the correlations reported in the section 'Heterogeneity and effect sizes' in the main manuscript 

#1. Standardized mean differences----
SMDs <- tau2_per_type %>% filter(effect_type == "Standardized Mean Difference")

cor.test(SMDs$tau2, SMDs$eff_size) #pearson tau2
cor.test(SMDs$s_I2, SMDs$eff_size) #pearson I2
cor.test(SMDs$H2, SMDs$eff_size) #pearson H2

cor.test(SMDs$tau2, SMDs$eff_size, method = "spearman") #spearman
cor.test(SMDs$s_I2, SMDs$eff_size, method = "spearman") #spearman
cor.test(SMDs$H2, SMDs$eff_size, method = "spearman") #spearman


##Excluding anchoring effects
dropped_anchoring <- SMDs %>%
  filter(!grepl("Anchoring", effect))

cor.test(dropped_anchoring$s_I2, dropped_anchoring$eff_size) #pearson

#bootstrap confidence intervals
#code by Amir Abdol


#1.1 I2 confidence intervals----
pear <- function(formula, data, indices){ #pearson
     d <- data[indices,]
     fit <- cor.test(formula = ~ s_I2 + eff_size, data=d)
     return(fit$estimate)
}

bootfit <- boot(data=SMDs, statistic=pear, R=1000, formula= ~ eff_size + s_I2)
I2_ci_pears <- boot.ci(bootfit, type=c("perc", "bca")) #percentile and adjusted percental method (BCa)


#Excluding anchoring effects
bootfit <- boot(data=dropped_anchoring, statistic=pear, R=1000, formula= ~ eff_size + s_I2)

I2_dropped_ci_pears <- boot.ci(bootfit, type=c("perc", "bca")) #percentile and adjusted percental method (BCa)

#1.2 Tau2 confidence intervals----
pear <- function(formula, data, indices){
     d <- data[indices,]
     fit <- cor.test(formula = ~ tau2 + eff_size, data=d)
     return(fit$estimate)
}

bootfit <- boot(data=tau2_per_type, statistic=pear, R=1000, formula= ~ eff_size + tau2)

tau2_ci_pears <- boot.ci(bootfit, type=c("perc", "bca"))

#Excluding anchoring effects
cor.test(dropped_anchoring$tau2, dropped_anchoring$eff_size)

bootfit <- boot(data=dropped_anchoring, statistic=pear, R=1000, formula= ~ eff_size + tau2)

tau2_dropped_ci_pears <- boot.ci(bootfit, type=c("perc", "bca")) #percentile and adjusted percental method (BCa)


#1.3 H2 confidence intervals----
pear <- function(formula, data, indices){
     d <- data[indices,]
     fit <- cor.test(formula = ~ H2 + eff_size, data=d)
     return(fit$estimate)
}

bootfit <- boot(data=tau2_per_type, statistic=pear, R=1000, formula= ~ eff_size + H2)

H2_ci_pears <- boot.ci(bootfit, type=c("perc", "bca"))



#1.4 spearman bootstrap CIs----
#First for I2
spear <- function(formula, data, indices){ #spearman
     d <- data[indices,]
     fit <- cor.test(formula = ~ s_I2 + eff_size, data=d, method = "spearman")
     return(fit$estimate)
}

options(warn=-1)
bootfit <- boot(data=tau2_per_type, statistic=spear, R=1000, formula= ~ eff_size + s_I2)
options(warn=0)

I2_ci_spear <- boot.ci(bootfit, type=c("perc", "bca"))

#Second for tau2
spear <- function(formula, data, indices){ #spearman
     d <- data[indices,]
     fit <- cor.test(formula = ~ tau2 + eff_size, data=d, method = "spearman")
     return(fit$estimate)
}

options(warn=-1)
bootfit <- boot(data=tau2_per_type, statistic=spear, R=1000, formula= ~ eff_size + tau2)
options(warn=0)

tau2_ci_spear <- boot.ci(bootfit, type=c("perc", "bca"))

#2. Fisher's z----
fish <- tau2_per_type %>% filter(effect_type == "Fisher's z" )
cor.test(fish$tau2, fish$eff_size) #pearson tau2
cor.test(fish$s_I2, fish$eff_size) #pearson I2
cor.test(fish$H2, fish$eff_size)

```

