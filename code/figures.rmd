---
title: "Figures"
author: "Anton Ohlsson Collentine"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

```{r load data and packages}
library(readr)
library(dplyr)
library(kableExtra)
library(purrr)
library(metafor)

dat <- read_csv("../data/collated_summary_data.csv")
```

I have four different types of effects to transform to raw correlations:
- mean difference + SE
- mean difference + SD
- RD
- OR

Should I first run MA and then transform effect sizes? ->Not sure how how to treat the raw mean differences, since I only get the MA-estimate estimate and the SE.  More straightforward to convert to common metric first. **Kolden + Ihle give formulas.**

```{r transformation_functions}
#For raw mean difference + SE
transform_SE <- function(ES, SE, n1, n2){ #ES -> SDp based on meta-analysis lecture 02
  sdpooled <- sqrt(SE^2 / (1 / n1 + 1/n2))
  d <- ES / sdpooled
  corr <- (n1 + n2)^2 / (n1*n2) #correction factor if unequal sample sizes
  r <- d / sqrt(d^2 + corr)
  data.frame(r = r, n = n1 + n2)
}

#For mean differrence + SD
transform_SD <- function(m1, m2, SD1, SD2, n1, n2){ #assumes ES is raw mean difference
  sdpooled <- sqrt(((n1 - 1)*SD1^2 + (n2 - 1)*SD2^2) / (n1 + n2 - 2)) #taken from Kolden from Esther
  d <- (m1 - m2) / sdpooled
  corr <- (n1 + n2)^2 / (n1*n2) #correction factor if unequal sample sizes
  r <- d / sqrt(d^2 + corr)
  data.frame(r = r, n = n1 + n2)
}

#For Risk difference/OR
transform_RD <- function(ai, bi, ci, di){
  ai <- ifelse(ai == 0, 0.5, ai)  #If value is equal to zero add one half so as to not divide by zero
  bi <- ifelse(bi == 0, 0.5, bi)  #This affects 1 study for Allowed vs. forbidden
  ci <- ifelse(ci == 0, 0.5, ci)  #And several studies for Low vs. high category scales
  di <- ifelse(di == 0, 0.5, di)
  logOR <- log((ai*di) / (bi*ci))
  d = logOR * sqrt(3)/pi
  n1 = ai + bi
  n2 = ci + di
  corr <- (n1 + n2)^2 / (n1*n2) #correction factor if unequal sample sizes
  r <- d / sqrt(d^2 + corr)
  data.frame(r = r, n = ai + bi + ci +di)
}

#No transformatin needed for correlation


transform_MA <- function(x){
  if(any(x[, "effect_type"] == "Risk difference")){ #without the 'any' we will get warnings because we apply 'if' to a vector
    
    transformed <- transform_RD(ai = x$outcome_t1, bi = x$outcome_t2, ci = x$outcome_c1, di = x$outcome_c2)
    
    #fit <- rma(measure = "ZCOR", ri = zcor, ni = n, test = "knha", data = transformed)
    
  } else if(any(x[, "outcomes1_2"] == "mean _ SE")){  
    
     transformed <- transform_SE(x$effect_size, x$outcome_c2, x$ntreatment, x$ncontrol)
    
    #fit <- rma(measure = "ZCOR", ri = zcor, ni = n, test = "knha", data = transformed)
  
  } else if(any(x[, "outcomes1_2"] == "mean _ SD")){  
    
     transformed <- transform_SD(x$outcome_t1, x$outcome_c1, x$outcome_t2, x$outcome_c2, x$ntreatment, x$ncontrol)
    
    # fit <- rma(measure = "ZCOR", ri = zcor, ni = n, test = "knha", data = transformed)
 
  } else if(any(x[, "effect_type"] == "r")){
    
     transformed <- data.frame(r = x$effect_size, n = x$Ntotal)
    
    # fit <- rma(measure = "ZCOR", ri = zcor, ni = n, test = "knha", data = transformed)
 
   } else{ #For the many labs OR that were transformed to d [double check]
    
     transformed <- transform_RD(ai = x$outcome_t1, bi = x$outcome_t2, ci = x$outcome_c1, di = x$outcome_c2)
     
}
  
  # data.frame(b = fit$b[[1]], I2 = fit$I2) #estimate out
  transformed
}
```

Transform effect sizes to raw correlations
```{r transform_df}
res <- dat %>% 
  split(.$effect) %>%  #separate by effect, necessary step otherwise the function is applied overall
  map_dfr(transform_MA, .id = "effect") 

res %>% filter(!is.na(r) & r > 1) #checks
res %>% filter(is.na(r)) #Checks
```

Seems okay. Metafor takes raw correlations as input for Fisher's z transformed rma.

```{r MA_df}
summarizer <- function(x){
  fit <- rma(measure = "ZCOR", ri = x$r, ni = x$n, test = "knha", data = x) #takes raw correlation as input
  data.frame(z = fit$b[[1]], I2 = fit$I2, H2 = fit$H2, H2alt = fit$QE / fit$k) #estimate out
}
#Alternative version of calculating I2 does not make conceptual sense because gives negative values. Alternative method for calculating H2 provides information also on excessive homogeneity (i.e, less variability than expected by chance) for those interested. (that is, does not have a lower limit of 1)
  
res2 <- res %>% 
  split(.$effect) %>%  #separate by effect, necessary step otherwise the function is applied overall
  map_dfr(summarizer, .id = "effect") %>% 
  mutate(z = abs(z)) #We are interested in effect size rather than direction
```

Above seems to do what it should. 

```{r plot_res}
library(ggplot2)


ggplot(res2, aes(x = z, y = I2)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  ggtitle("I2 increases with effect size in pre-registered multi-lab studies") +
  xlab("Fisher's z") +
  coord_cartesian(ylim = c(0, 100)) +
  geom_text(x = 0.1, y = 75, label = "b = 69.40, R2 = 0.61", size = 3.5)

# ggsave("I2_effect_size.png")

ggplot(res2, aes(x = z, y = H2alt)) + 
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  ggtitle("H2 increases with effect size in pre-registered multi-lab studies") +
  xlab("Fisher's z") +
  geom_text(x = 0.1, y = 6, label = "b = 3.81, R2 = 0.53", size = 3.5)


# summary(lm(I2 ~ z, data = res2)) #b = 69.40, R2 = 0.61
# summary(lm(H2alt ~ z, data = res2)) #b = 3.81, R2 = 0.53
```

Note that Fisher's z are the absolute z-scores, because we are interested in effect size rather than direction.

```{r labelled_plot}
library(ggplot2)


ggplot(res2, aes(x = z, y = I2, label = effect)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE) +
  geom_text(alpha = 0.3)
```

Qs: Should I keep the I2 based on the original scales, but transform the effect sizes and plot that instead (seems not unreasonable since I2 depends on effect type). -> This seems to make little difference, see below.

```{r}
est_heterogen_smd_raw <- function(x){
  if(any(x[, "effect_type"] == "Risk difference")){ #without the 'any' we will get warnings because we apply 'if' to a vector
    
    fit <- rma(measure = "RD", ai = outcome_t1, bi = outcome_t2, ci = outcome_c1, di = outcome_c2,  n1i = ntreatment, n2i = ncontrol, test = "knha", data = x)
    
  } else if(any(x[, "outcomes1_2"] == "mean _ SE")){  
    
    fit <-  rma(yi = effect_size, sei = outcome_c2, test = "knha",  data = x) 
  
  } else if(any(x[, "effect_type"] == "Raw mean difference")){  
    
    fit <- rma(measure = "MD", m1i = outcome_t1, m2i = outcome_c1, sd1i = outcome_t2, sd2i = outcome_c2, n1i = ntreatment, n2i = ncontrol,test = "knha", data = x) 
  
  } else if(any(x[, "outcomes1_2"] == "mean _ SD")){  
    
    fit <- rma(measure = "SMD", m1i = outcome_t1, m2i = outcome_c1, sd1i = outcome_t2, sd2i = outcome_c2, n1i = ntreatment, n2i = ncontrol,test = "knha", data = x) 
       
  } else if(any(x[, "effect_type"] == "r")){
    
    fit <- rma(measure = "COR", ri = effect_size, ni = Ntotal, test = "knha", data = x)

  } else{ #for all two-group count effects
    
    fit <- rma(measure = "OR2DL", ai = outcome_t1, bi = outcome_t2, ci = outcome_c1, di = outcome_c2, #standardized, ML1 used 'OR2D' but that = 'OR2DL'
               n1i = ntreatment, n2i = ncontrol, test = "knha", data = x)
    
  }
  
  I2_1 <- confint(fit)$random[3, ] #Gives us the I2 estimate and its confidence interval
  data.frame(eff_size = fit$b[[1]], #effect size (point estimate)
             p = fit$pval,
             s_I2 = I2_1[1], s_ci.lb = I2_1[2], s_ci.ub = I2_1[3]) #I2 + CI
}

#Apply function to data
res3 <- dat %>% 
  split(.$effect) %>%  #separate by effect, necessary step otherwise the function is applied overall
  map_dfr(est_heterogen_smd_raw, .id = "effect") %>% 
  select(effect, s_I2) %>% 
  left_join(res2, .)

```


```{r}
ggplot(res3, aes(x = z, y = s_I2)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)

summary(lm(s_I2 ~ z, data = res3)) #b = 68.23, R2 = 0.67
```

